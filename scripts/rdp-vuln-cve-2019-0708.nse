local nmap = require "nmap"
local shortport = require "shortport"
local stdnse = require "stdnse"
local string = require "string"
local vulns = require "vulns"

description = [[
Checks if a machine is vulnerable to BlueKeep RDP vulnerability (CVE-2019-0708).


References:
* https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2019-0708
* https://zerosum0x0.blogspot.com/2019/05/avoiding-dos-how-bluekeep-scanners-work.html

]]

---
-- @usage
-- nmap -sV --script=rdp-vuln-cve-2019-0708 -p 3389 <target>
--
-- @output
-- PORT     STATE SERVICE        VERSION
-- 3389/tcp open  ms-wbt-server?
-- | rdp-vuln-cve-2019-0708:
-- |   VULNERABLE:
-- |   CVE-2019-0708 Remote Desktop Protocol BlueKeep Vulnerability
-- |     State: VULNERABLE
-- |     IDs:  CVE:CVE-2019-0708
-- |     Risk factor: Critical  CVSSv3.0: 9.8 (CRITICAL) (AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H)
-- |     Description:
-- |               Remote Desktop Protocol vulnerability that could allow remote attackers to execute arbitrary code on the targeted system.
-- |
-- |     Disclosure date: 2019-09-06
-- |     References:
-- |       https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2019-0708
-- |       https://nvd.nist.gov/vuln/detail/CVE-2019-0708
-- |       https://www.thezdi.com/blog/2019/5/27/cve-2019-0708-a-comprehensive-analysis-of-a-remote-desktop-services-vulnerability

author = "offsec1"
license = "Same as Nmap--See https://nmap.org/book/man-legal.html"
categories = {"intrusive", "vuln"}
portrule = shortport.port_or_service({3389},{"ms-wbt-server"})

action = function(host, port)
  local socket = nmap.new_socket()
  local status, err,response

  -- https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpbcgr/e78db616-689f-4b8a-8a99-525f7a433ee2
  local x_224_conn_req = "0300002b"   -- TPKT Header
  .. "26"                                   -- X.224 Data TPDU length
  .. "e0"                                   -- X.224 Type (Connection request)
  .. "0000"                                 -- X.224: Destination reference
  .. "0000"                                 -- X.224: Source reference
  .. "00"                                   -- X.224: Class and options
  .. "436f6f6b69653a206d737473686173683d"   -- "Cookie: mstshash=
  .. "656c746f6e"                           -- Cookie value: elton -> HEX
  .. "0d0a"                                 -- Cookie terminator sequence
  .. "01"                                   -- Type: RDP_NEG_REQ)
  .. "00"                                   -- RDP_NEG_REQ::flags
  .. "0800"                                 -- RDP_NEG_REQ::length (8 bytes)
  .. "00000000"                             -- Requested protocols (PROTOCOL_RDP)
  local connectionRequest = stdnse.fromhex(x_224_conn_req)

  -- https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpbcgr/db6713ee-1c0e-4064-a3b3-0fac30b4037b
  local pdu_connect_initial = "030001ca02f0807f658201be0401010401010101ff3020020200220202000202020000020"
  .. "2000102020000020200010202ffff020200023020020200010202000102020001020200010202000002020001020204200"
  .. "202000230200202ffff0202fc170202ffff0202000102020000020200010202ffff020200020482014b000500147c00018"
  .. "142000800100001c00044756361813401c0d800040008002003580201ca03aa09040000280a0000"
  .. "78003100380031003000"     -- HOSTNAME
  .. "0000000000000000000000000000000000000000000004000000000000000c000000000000000000000000000000000000"
  .. "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
  .. "01ca0100000000001800070001000000000000000000000000000000000000000000000000000000000000000000000000"
  .. "000000000000000000000000000000000000000000000000000000000000000000000004c00c00090000000000000002c0"
  .. "0c00030000000000000003c0440005000000636c697072647200c0a000004d535f543132300080800000726470736e6400"
  .. "00c0000000736e646462670000c0000000726470647200000080800000"
  local pduRequest = stdnse.fromhex(pdu_connect_initial)

  --  https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpbcgr/04c60697-0d9a-4afd-a0cd-2cc133151a9c
  local pdu_errect_domain = "0300000c02f0800400010001"
  local pduErrectDomainRequest = stdnse.fromhex(pdu_errect_domain)

  local rdp_vuln_bluekeep  = {
    title = "CVE-2019-0708 Remote Desktop Protocol BlueKeep Vulnerability",
    IDS = {CVE = 'CVE-2019-0708'},
    risk_factor = "Critical",
    scores = {
      CVSSv3 = "9.8 (CRITICAL) (AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H)",
    },
    description = [[
    Remote Desktop Protocol vulnerability that could allow remote attackers to execute arbitrary code on the targeted system.
    ]],
    references = {
      'https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2019-0708',
      'https://nvd.nist.gov/vuln/detail/CVE-2019-0708',
      'https://www.thezdi.com/blog/2019/5/27/cve-2019-0708-a-comprehensive-analysis-of-a-remote-desktop-services-vulnerability',
    },
    dates = {
      disclosure = {year = '2019', month = '09', day = '06'},
    },
    exploit_results = {},
  }
  local report = vulns.Report:new(SCRIPT_NAME, host, port)
  rdp_vuln_bluekeep.state = vulns.STATE.NOT_VULN

  -- Sleep for 0.2 seconds to make sure the script works even with SYN scan.
  -- Posible reason for this is that Windows resets the connection if we try to
  -- reconnect too fast to the same port after doing a SYN scan and not completing the
  -- handshake. In my tests, sleep values above 0.1s prevent the connection reset.
  stdnse.sleep(0.2)

  socket:connect(host.ip, port)

  stdnse.debug1("[+] Verifying RDP protocol")
  status, err = socket:send(connectionRequest)
  status, response = socket:receive_bytes(0)

  stdnse.debug1("[+] PDU X.224 Response Received")

  -- https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rdpbcgr/49095420-c6ef-4256-a262-3800e1e233a7
  -- TODO does this check work for other deveices than mine?
  if response ~= stdnse.fromhex("030000130ed000001234000201080000000000") then
    --probably not rdp at all
    stdnse.debug1("not RDP")
    return nil
  end

  stdnse.debug1("[+] Sending MCS Connect Initial PDU with GCC Conference")
  status, err = socket:send(pduRequest)
  status, response = socket:receive_bytes(0)

  stdnse.debug1("[*] MCS Response PDU with GCC Conference Received")

  -- parse pdu response and get important information from the response
  rsmod, rsexp, rsran, server_random, bitlen = parse_serverdata(response)
  stdnse.debug(1, "[*] RSMOD: ", stdnse.tohex(rsmod))
  stdnse.debug(1, "[*] RSEXP: ", stdnse.tohex(rsexp))
  stdnse.debug(1, "[*] RSRAN: ", stdnse.tohex(rsran))
  stdnse.debug(1, "[*] SERVER_RANDOM: ", stdnse.tohex(server_random))
  stdnse.debug1("[*] Finished parsing pdu_connect_initial response")

  if 1 == 1 then
    socket:close()
    rdp_vuln_bluekeep.state = vulns.STATE.VULN
  end
  --service is not vulnerable
  socket:close()
  return report:make_output(rdp_vuln_bluekeep)
end

function parse_serverdata(pkt)
  stdnse.debug1("[*] Parsing pdu_connect_initial response: ")

  local rsmod, rsexp, rsran, server_random, bitlen, modulus, header_type, header_length, public_exponent, rsa_magic
  local ptr = 0
  local rdp_pkt = pkt:sub(74, pkt:len())
  stdnse.debug1(stdnse.tohex(rdp_pkt))

  while ptr < rdp_pkt:len() do
    header_type = rdp_pkt:sub(ptr, ptr+2)
--    if ptr ~= 0 then
--      header_type = rdp_pkt:sub(ptr+1, ptr+2)
--    end
    header_length = string.unpack("<h", rdp_pkt:sub(ptr+3, ptr+4))

    stdnse.debug(1, "[+] HEADER: %s   LEN: %d", stdnse.tohex(header_type), header_length)

    if header_type == stdnse.fromhex("020c") then
      stdnse.debug1("[*] Extracting security information from rdp_pkt")
      server_random = rdp_pkt:sub(ptr+21, ptr+52)
      public_exponent = rdp_pkt:sub(ptr+85, ptr+88)
      modulus = rdp_pkt:sub(ptr+89, ptr+152)
      rsa_magic = rdp_pkt:sub(ptr+69, ptr+72)

      if rsa_magic ~= stdnse.fromhex("52534131") then
        stdnse.debug1("[-] Server certificate is NOT RSA!")
      end

      bitlen = string.unpack("<I4", rdp_pkt:sub(ptr+73, ptr+76))
      stdnse.debug(1, "[*] RSA bitlen: %d", bitlen)
      modulus = rdp_pkt:sub(ptr+89, ptr+87+1+bitlen)

    end

    ptr = ptr + header_length
  end

  -- TODO this needs to be converted first
  rsmod = modulus
  rsexp = public_exponent
  rsran = server_random

  return rsmod, rsexp, rsran, server_random, bitlen
end
